
탐욕 알고리즘 (greedy algorithm)
====
```
1. 무엇인가? (정의)
2. 언제 사용할 수 있나?
3. 어떻게 사용하는 가?
```

# 1.무엇인가?

동적 계획법은 필자 기준 학습자들에게 고통을 안기는 대표적인 작명 사례이다. 왠지 메모리 할당에 관련할 듯한 "동적"은 이 알고리즘과 전혀 관계가 없으며, 한 줄로 설명하자면 "완전 탐색을 할 때, 부분 문제의 해를 캐싱(메모이제이션)하여 전체 문제의 해를 구해나가는 알고리즘"이라고 할 수 있다. "기억하며 풀기"라는 번역이 더 적절하다고 생각하며, 이하 DP로 부르겠다.

# 2.언제 사용할 수 있나?

어떤 알고리즘 문제가 아래 두 가지 구성요건을 만족할 경우, DP로 "해결가능" 한 문제이다. 여기서 주의해야할 점은 실행 환경과 문제의 제약 조건에 따라 더 효율적인, 즉 CPU 시간과 메모리 공간을 덜 소모하는 해결법이 존재할 수 있다는 것이다. 대표적인 사례로는 다익스트라, 최소 신장 트리 등이 있다. 하지만 다익스트라 DP는 기본적으로 완전 탐색의 접근법을 취하기 때문에, 제대로 동작하는 코드를 만들 수 있다면 최적 해를 구하는 것은 보장한다.

### **겹치는 하위 문제 Overlapping subproblems** 

전체 문제가 여러 번 반복되어(혹은 재귀적으로) 활용될 수 있는 부분 문제로 분해될 수 있을 때, 겹치는 하위 문제를 가진다고 한다. 지금까지 학습을 하면서, 이항 계수 재귀 호출을 도식화한 아래 이미지가 가장 직관적인 이해를 도와줬었다. 아래는 이항계수(nCr) 구하는 과정을 도식화 한 것이다.

* 이항계수의 일반 식, n > k, n과 k는 자연수

![BINO](7.bino.png)

![DPTREE1](7.dp_tree1.png) 

위 그림에서 보면, bino(2,1)과 bino (1,1), bino(1,0)은 반복해서 호출이 된다. 이 때, 아래 그림과 같이 반복되는 부분 문제의 해를 "기억" 하여 더 큰 부분 문제를 풀 때 활용한다면, 메모리 공간을 이용하여 해 탐색에 소요되는 시간을 절약 할 수 있다. 

![DPTREE2](7.dp_tree2.png)

이 때 "기억" 하고 있는 부분 문제는 1번의 호출(혹은 연산 또는 탐색.. 뭐라고 부르든)로 확정된다고 보장하지 않는 다. 어떤 부분문제를 1번만 풀고, 더 큰 부분 문제에 상수처럼 활용할 수 있는 문제들은 쉬운 DP 문제에 속한다고 보면 된다.

### **최적 부분 구조 Optimal substructure** 

'최적 부분 구조'는 전체의 최적해는 무조건 부분 문제의 최적해를 포함한다는 것이다. 동시에 전체 문제를 쪼개서 구한 최적해가 무조건 전체 최적해에 들어간다는 뜻이다. 동적계획법 문제와 같은 전제조건이고, 이 때문에 알고리즘 문제들을 풀 때 그리디인가? DP인가? 헷갈리게 만드는 이유이기도 하다.


# 3. 어떻게 사용하는 가?


## 예제. 거스름돈

앞서 탐욕법 챕터의 거스름 돈 문제를 DP 기반으로 풀어, 일반적으로 활용 가능한 솔루션을 만들어보자