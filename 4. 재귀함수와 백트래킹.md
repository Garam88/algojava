재귀함수와 백트래킹
========================

## 들어가며
이를테면, 1~6까지의 눈이 있는 정육면체 주사위를 던져서 나올 수 있는 모든 경우의 수를 오름차순으로 출력해 본다고 해 봅시다.  
이를 코드로 구현한다면 반복문과 출력명령어로 간단하게 나타 낼 수 있습니다.

```
for (int i = 1; i <= 6; i++) {
    System.out.println("dice_result: " + i);
}

---------------
dice_result: 1
dice_result: 2
...
dice_result: 6
---------------
```

만약 주사위가 두개라면? 반복문 안에 또 다른 반복문이 들어가있는 이중 for문을 사용하면 해결 할 수 있습니다.
```
for (int i = 1; i <= 6; i++) {
    for (int j = 1; j <= 6; j++) {
        System.out.println("dice_result: " + i + ", " + j);
    }
}
------------------
dice_result: 1, 1
dice_result: 1, 2
...
dice_result: 6, 6
------------------

```

이를 응용하면 주사위의 개수 n이 주어졌을 경우의 모든 경우의 수를 구할 수 있을 것입니다.

```
for (int i = 1; i <= 6; i++) {
    for (int j = 1; j <= 6; j++) {
        for (int k = 1; k <= 6; k++) {
            ...(생략)...
            System.out.println("dice_result: " + i + ", " + j + ...(생략));
        }
    }
}
------------------------------
dice_result: 1, 1, 1, ... , 1
dice_result: 1, 1, 1, ... , 2
...
dice_result: 6, 6, 6, ... , 6
------------------------------

```
**하지만 이러한 코드는 같은 연산을 수행하는 코드가 중첩되어 비효율적이며, 무엇보다도 주사위의 개수가 주어지지 않았을 경우(조건 또는 연산 결과에 따라 수행 횟수가 변할 경우) 대응할 수 없다**는 치명적인 단점이 있습니다.

## 재귀함수(再歸,Recursion Function)
재귀함수란 말 그대로 자기자신을 다시 호출함으로써 재참조하는 함수를 의미합니다.  
일반적으로 특정 조건을 만족할 때까지 계속해서 자기자신을 호출하게 되며, 조건을 만족하는 경우에 함수가 종료되는 구조를 갖습니다.
재귀함수의 가장 대표적인 경우인 factorial을 구현해보면 아래와 같습니다.


```
private static int fact(int i) {
		if (i == 1) {
			return 1;
		} else {
			return i * fact(i - 1);
		}
	}
```
재귀함수를 이해하기 위한 가장 중요하고 기본적인 개념은,  
**함수는 호출되는 즉시 새로운 함수를 생성하여 연산을 수행**하게 된다는 것입니다.  
좀 더 직관적인 이해를 위해 위의 코드를 아래와 같이 바꾸어봅시다.
```
public static void main(String[] args) {
		int result = fact(4);
		System.out.println(result);
}

private static int fact(int i) {
//  System.out.println("fact(" + i + ")를 호출합니다.");
    int result = 0;
    if (i == 1) {
        result = 1;
//      System.out.println("fact(1)=1");
    } else {
        result = fact(i - 1) * i;
//      System.out.println("fact(" + (i - 1) + ") * " + i + " = " + result);
    }
//  System.out.println("fact(" + i + ")를 종료합니다.");
```

코드가 실행되면서 일어지는 일을 간단히 도식화 해 보면 다음과 같습니다.  
<그림>
![Recuresive](.algojava/recursive.PNG)

처음 main함수에서 i에 4의 값을 가진 채 fact함수를 호출하면 fact함수가 새로 생성되어 메모리에 올라가게 됩니다.(①)   
호출된 fact(4)함수의 코드를 차례대로 읽어가다 보면 fact(i-1)을 만나고, 이때 i=4이므로 fact(3)을 다시호출(②)하게 됩니다. 마찬가지로 fact(2), fact(1)을 차례대로 호출하게 되지요(③,④).  
fact(1)이 실행되면서 result=1을 부여받은 후 return이 이루어지고(⑤) result값을 갱신하며 연산하여 return합니다.  
마지막으로, 처음 호출된 fact(4)함수의 result값이 갱신되어(4 * 3 * 2 * 1) return 되면 main 함수로 돌아가게 됩니다.  
  
  
많은 분들이 재귀함수를 호출하면 다시 함수의 처음으로 돌아간다고 생각하십니다. 이렇게 될 경우, return을 통해 값을 받아오는 부분이 해석되지 않고, 이후 나올 백트래킹을 이해 하는데 큰 어려움이 있습니다.앞서 말씀드렸듯이, 처음 재귀함수를 이해함에 있어 가장 중요한 것은 **함수는 호출되는 즉시 새로운 함수를 생성하여 연산을 수행**하게 된다는 것입니다.  
잘 이해가 되지 않으실 경우, 위 코드의 print문의 주석부분을 해제하고 실행해보시면서 공부를 하시기를 추천드립니다.
--------------------------------------------------------------------------------

##백트래킹(Back Tracking)

백트래킹은 재귀함수를 이용하는 대표적인 알고리즘입니다. 앞으로 다룰 BFS, DFS를 백트래킹의 종류로 볼 수도 있지만, 본 장에서는 단순히 재귀로 구현하는 경우를 백트래킹이라고 정의한 후 설명 하려고 합니다.  
백트래킹은 기본적으로 **모든 경우의 수를 탐색** 하게 됩니다. 따라서 (어떤경우에는) 사람이라면 쉽게 나올 수 있는 정답을 찾기위해 많은 시간과 자원을 소모하는 경우도 있습니다. 하지만 반대로 가질 수 있는 모든 경우의 수를 전부 따져 보기 때문에 *"반드시"* 정답을 구할 수 있는 방법이기도 합니다. 가장 유명한 문제로는 체스판 위에 N개의 퀸을 배치하는 N-Queen 문제가 있지요. 지금부터 차근차근 백트래킹의 개념을 살펴 보겠습니다.  
이를테면, 아래와 같은 4*4 배열에서 4개의 숫자를 골라서 더해 가장 큰 수를 만드는 예제가 있다고 해봅시다. 단, 각 행과 열에서는 한 개의 숫자만 더할 수 있다는 조건이 있습니다.
<그림>
12 13 21 9
42 39 50 45
30 18 39 40
51 59 57 39

앞에서 설명드린 문제는 가장 전형적인 백트래킹 문제입니다. 백트래킹의 기본 개념인 **모든 경우의 수를 탐색** 할 필요가 있는 것이지요. (0,0) 부터 (3,3)까지의 16개의 숫자 중 조건의 맞는 4개의 수를 선택한 후 그 합을 비교하여 최대값을 구해야 합니다.(이후부터는 편의를 위해 0행~3행, 0열~3열로 표기하도록 하겠습니다.)  
경우에 따라 다르겠지만, 백트래킹 문제는 기본적으로 아래와 같은 구조를 같습니다.
   <Main 함수>
   1. 변수 생성
   2. Backtrack 함수 호출

   <Backtrack 함수>
   1. (가지치기)
   2. 탈출조건 확인
   3. 반복문,조건물을 통해 Backtrack 함수 재귀호출

1. Main 함수  
    1-1. 변수 생성    
    문제를 푸는데 필요할 전역(static), 지역(local)변수들을 만들게 됩니다.  
    백트래킹 문제에서는 *중복을 허용하지 않는다, 각 행과 열에서는 한 개의 숫자만 선택 할 수 있다, 방문한 곳을 다시 갈 수 없다* 등의 조건을 자주 발견할 수 있습니다. 일반적으로 이를 해결하기 위해서 배열을 하나 만들어서 다녀온 곳을 체크해 놓곤 합니다. 우리는 이 배열을 **visited**라는 이름으로 사용하도록 하겠습니다. 즉, 각 행에서 숫자를 고르고 선택한 숫자의 열에 체크를 해 놓을 생각입니다.  
    알고리즘 문제 풀이에 익숙하지 않으시다면, 한 번에 모든 변수들을 만드려고 할 필요가 없습니다. 코드 작성중에 '이런 변수도 필요할 것 같은데...'라는 생각이 들때마다 추가하시면 됩니다.  
    <그림>  
    12 13 21 9  
    42 39 50 45  
    30 18 39 40  
    51 59 57 39  
    선택->12  
    [1,0,0,0]

    1-2. BackTrack 함수 호출  
    이제 백트래킹을 위한 함수를 생성하여 호출하려고 합니다. 함수는 인자를 가지고 이동을 하게 됩니다. 함수들이 생성되고 연산 할 때 어떤 값들이 필요한가, 반환값(return)은 어떤 형태인가를 따져가면 함수를 만들게 됩니다.  
    많은 분들이 괄호 안에 어떤 인자를 넣어야하나 질문을 합니다. 바꿔 말하면 "어떤 변수를 전역변수으로 만들 것인가"에 대한 고민이지요. 개인적인 생각으로는 정답은 없으며, 본인의 취향대로 하시라고 대답을 드리곤 합니다. 저의 경우에는 함수를 호출하면서 자주 변하는 간단한 값(cnt, result)들을 인자로 만들고, 자주 변하지 않거나 사이즈가 큰 변수, 문제를 풀기 위해 참조하는 값(mat, visited) 들을 전역변수로 할당하곤 합니다. 하지만 이는 개인적인 취향으로, 적절히 사용하시면 됩니다.  

2. Backtrack 함수  
    2-0. 가지치기  
    경우의 수가 너무 많을 경우, 가지치기를 통해 자원과 시간을 아끼게 됩니다. 위의 예제의 경우 모든 경우의 수는 4! 즉, 24개 밖에 되지 않겠지요. 하지만 행과 열이 10개로 늘어나게 되면 360만개가 넘는 경우가 발생하여 실행 후 결과출력까지 꽤 오랜 시간이 걸리게 됩니다.  
    경우에 따라서는 문제 조건에 맞는 가지치기를 통해 시간과 자원을 절약하는 것이 필요할 떄가 있습니다.  

    2-1. 탈출조건  
    탈출조건이란 탐색을 멈추고 값을 반환하는 경우를 말합니다. 예를 들어 위의 경우에는 마지막 3행에서 숫자의 선택 끝나게 되면 재귀호출을 중지해야 합니다.(한 번 더 호출을 수행하게 되면 array index out of bound exception이 발생하게 되겠지요.)  
    이번 예제의 경우에는, 선택이 끝나면 기존의 Answer값과의 비교를 통해 필요할 경우 값을 갱신하는 로직이 필요할 것입니다.

    2-2