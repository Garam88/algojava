재귀함수와 백트래킹
========================

## 들어가며
이를테면, 1~6까지의 눈이 있는 정육면체 주사위를 던져서 나올 수 있는 모든 경우의 수를 오름차순으로 출력해 본다고 해 봅시다.  
이를 코드로 구현한다면 반복문과 출력명령어로 간단하게 나타 낼 수 있습니다.

```
for (int i = 1; i <= 6; i++) {
    System.out.println("dice_result: " + i);
}

---------------
dice_result: 1
dice_result: 2
...
dice_result: 6
---------------
```

만약 주사위가 두개라면? 반복문 안에 또 다른 반복문이 들어가있는 이중 for문을 사용하면 해결 할 수 있습니다.
```
for (int i = 1; i <= 6; i++) {
    for (int j = 1; j <= 6; j++) {
        System.out.println("dice_result: " + i + ", " + j);
    }
}
------------------
dice_result: 1, 1
dice_result: 1, 2
...
dice_result: 6, 6
------------------

```

이를 응용하면 주사위의 개수 n이 주어졌을 경우의 모든 경우의 수를 구할 수 있을 것입니다.

```
for (int i = 1; i <= 6; i++) {
    for (int j = 1; j <= 6; j++) {
        for (int k = 1; k <= 6; k++) {
            ...(생략)...
            System.out.println("dice_result: " + i + ", " + j + ...(생략));
        }
    }
}
------------------------------
dice_result: 1, 1, 1, ... , 1
dice_result: 1, 1, 1, ... , 2
...
dice_result: 6, 6, 6, ... , 6
------------------------------

```
**하지만 이러한 코드는 같은 연산을 수행하는 코드가 중첩되어 비효율적이며, 무엇보다도 주사위의 개수가 주어지지 않았을 경우(조건 또는 연산 결과에 따라 수행 횟수가 변할 경우) 대응할 수 없다**는 치명적인 단점이 있습니다.

## 재귀함수(再歸,Recursion Function)
재귀함수란 말 그대로 자기자신을 다시 호출함으로써 재참조하는 함수를 의미합니다.  
일반적으로 특정 조건을 만족할 때까지 계속해서 자기자신을 호출하게 되며, 조건을 만족하는 경우에 함수가 종료되는 구조를 갖습니다.
재귀함수의 가장 대표적인 경우인 factorial을 구현해보면 아래와 같습니다.


```
private static int fact(int i) {
		if (i == 1) {
			return 1;
		} else {
			return i * fact(i - 1);
		}
	}
```
재귀함수를 이해하기 위한 가장 중요하고 기본적인 개념은,  
**함수는 호출되는 즉시 새로운 함수를 생성하여 연산을 수행**하게 된다는 것입니다.  
좀 더 직관적인 이해를 위해 위의 코드를 아래와 같이 바꾸어봅시다.
```
public static void main(String[] args) {
		int result = fact(4);
		System.out.println(result);
}

private static int fact(int i) {
//  System.out.println("fact(" + i + ")를 호출합니다.");
    int result = 0;
    if (i == 1) {
        result = 1;
//      System.out.println("fact(1)=1");
    } else {
        result = fact(i - 1) * i;
//      System.out.println("fact(" + (i - 1) + ") * " + i + " = " + result);
    }
//  System.out.println("fact(" + i + ")를 종료합니다.");
```

코드가 실행되면서 일어지는 일을 간단히 도식화 해 보면 다음과 같습니다.  
<그림1>
![Recuresive](.algojava/recursive.PNG)

처음 main함수에서 i에 4의 값을 가진 채 fact함수를 호출하면 fact함수가 새로 생성되어 메모리에 올라가게 됩니다.(①)   
호출된 fact(4)함수의 코드를 차례대로 읽어가다 보면 fact(i-1)을 만나고, 이때 i=4이므로 fact(3)을 다시호출(②)하게 됩니다. 마찬가지로 fact(2), fact(1)을 차례대로 호출하게 되지요(③,④).  
fact(1)이 실행되면서 result=1을 부여받은 후 return이 이루어지고(⑤) result값을 갱신하며 연산하여 return합니다.  
마지막으로, 처음 호출된 fact(4)함수의 result값이 갱신되어(4 * 3 * 2 * 1) return 되면 main 함수로 돌아가게 됩니다.  
  
  
많은 분들이 재귀함수를 호출하면 다시 함수의 처음으로 돌아간다고 생각하십니다. 이렇게 될 경우, return을 통해 값을 받아오는 부분이 해석되지 않고, 이후 나올 백트래킹을 이해 하는데 큰 어려움이 있습니다.앞서 말씀드렸듯이, 처음 재귀함수를 이해함에 있어 가장 중요한 것은 **함수는 호출되는 즉시 새로운 함수를 생성하여 연산을 수행**하게 된다는 것입니다.  
잘 이해가 되지 않으실 경우, 위 코드의 print문의 주석부분을 해제하고 실행해보시면서 공부를 하시기를 추천드립니다.


## 백트래킹(Back Tracking)

복잡한 미로 속에서 출구를 찾는다고 가정해 봅시다. 출구를 찾는 가장 확실한 방법은, 갈림길을 발견했을 떄마다 동일한 방향으로 길을 선택해 나가며, 막다른 길을 발견했을 때는 바로 전의 갈림길에서부터 동일한 방법으로 탐색을 계속하는 것입니다. 즉, 자신의 발자국을 *되밟아가며(Backtrack)* 탐색을 하는 것입니다.  
<그림2>  

백트래킹은 재귀함수를 이용하는 대표적인 알고리즘입니다. 앞으로 다룰 BFS, DFS를 백트래킹의 종류로 볼 수도 있지만, 본 장에서는 단순히 재귀로 구현하는 경우를 백트래킹이라고 정의한 후 설명 하려고 합니다.  
백트래킹은 기본적으로 **모든 경우의 수를 탐색** 하게 됩니다. 따라서 (어떤경우에는) 사람이라면 쉽게 나올 수 있는 정답을 찾기위해 많은 시간과 자원을 소모하는 경우도 있습니다. 하지만 반대로 가질 수 있는 모든 경우의 수를 전부 따져 보기 때문에 *"반드시"* 정답을 구할 수 있는 방법이기도 합니다. 가장 유명한 문제로는 체스판 위에 N개의 퀸을 배치하는 N-Queen 문제가 있지요. 지금부터 차근차근 백트래킹의 개념을 살펴 보겠습니다.  
  
이를테면, 아래와 같은 4*4 배열에서 4개의 숫자를 골라서 더해 가장 큰 수를 만드는 예제가 있다고 해봅시다. 단, 각 행과 열에서는 한 개의 숫자만 선택하여 더할 수 있다는 조건이 있습니다.
<그림>
12 13 21 9
42 39 50 45
30 18 39 40
51 59 57 39

앞에서 설명드린 문제는 가장 전형적인 백트래킹 문제입니다. 백트래킹의 기본 개념인 **모든 경우의 수를 탐색** 할 필요가 있는 것이지요. (0,0) 부터 (3,3)까지의 16개의 숫자 중 조건의 맞는 4개의 수를 선택한 후 그 합을 비교하여 최대값을 구해야 합니다.(이후부터는 편의를 위해 0행~3행, 0열~3열로 표기하도록 하겠습니다.)  
경우에 따라 다르겠지만, 백트래킹 문제는 기본적으로 아래와 같은 구조를 같습니다.
   <Main 함수>
   1. 변수 생성
   2. Backtrack 함수 호출

   <Backtrack 함수>
   1. (가지치기)
   2. 탈출조건 확인
   3. 반복문,조건문을 통해 Backtrack 함수 재귀호출

1. Main 함수  
    1-1. 변수 생성    
    문제를 푸는데 필요할 전역(static), 지역(local)변수들을 만들게 됩니다.  
    백트래킹 문제에서는 *중복을 허용하지 않는다, 각 행과 열에서는 한 개의 숫자만 선택 할 수 있다, 방문한 곳을 다시 갈 수 없다* 등의 조건을 자주 발견할 수 있습니다. 일반적으로 이를 해결하기 위해서 배열을 하나 만들어서 다녀온 곳을 체크해 놓곤 합니다. 우리는 이 배열을 **visited**라는 이름으로 사용하도록 하겠습니다. 즉, 각 행에서 숫자를 고르고 선택한 숫자의 열에 체크를 해 놓을 생각입니다.  
    알고리즘 문제 풀이에 익숙하지 않으시다면, 한 번에 모든 변수들을 만드려고 할 필요가 없습니다. 코드 작성중에 '이런 변수도 필요할 것 같은데...'라는 생각이 들때마다 추가하시면 됩니다.  
    <그림>  
    12 13 21 9  
    42 39 50 45  
    30 18 39 40  
    51 59 57 39  
    선택->12  
    [1,0,0,0]

    1-2. BackTrack 함수 호출  
    이제 백트래킹을 위한 함수를 생성하여 호출하려고 합니다. 함수는 인자를 가지고 이동을 하게 됩니다. 함수들이 생성되고 연산 할 때 어떤 값들이 필요한가, 반환값(return)은 어떤 형태인가를 따져가면 함수를 만들게 됩니다.  
    많은 분들이 괄호 안에 어떤 인자를 넣어야하나 질문을 합니다. 바꿔 말하면 "어떤 변수를 전역변수으로 만들 것인가"에 대한 고민이지요. 개인적인 생각으로는 정답은 없으며, 본인의 취향대로 하시라고 대답을 드리곤 합니다. 저의 경우에는 함수를 호출하면서 자주 변하는 간단한 값(cnt, result)들을 인자로 만들고, 자주 변하지 않거나 사이즈가 큰 변수, 문제를 풀기 위해 참조하는 값(mat, visited) 들을 전역변수로 할당하곤 합니다. 하지만 이는 개인적인 취향으로, 적절히 사용하시면 됩니다.  

2. Backtrack 함수  
    2-0. 가지치기  
    경우의 수가 너무 많을 경우, 가지치기를 통해 자원과 시간을 아끼게 됩니다. 위의 예제의 경우 모든 경우의 수는 4! 즉, 24개 밖에 되지 않겠지요. 하지만 행과 열이 10개로 늘어나게 되면 360만개가 넘는 경우가 발생하여 실행 후 결과출력까지 꽤 오랜 시간이 걸리게 됩니다.  
    경우에 따라서는 문제 조건에 맞는 가지치기를 통해 시간과 자원을 절약하는 것이 필요할 떄가 있습니다.  

    2-1. 탈출조건  
    탈출조건이란 탐색을 멈추고 값을 반환하는 경우를 말합니다. 예를 들어 위의 경우에는 마지막 3행에서 숫자의 선택 끝나게 되면 재귀호출을 중지해야 합니다.(한 번 더 호출을 수행하게 되면 array index out of bound exception이 발생하게 되겠지요.)  
    이번 예제의 경우에는, 선택이 끝나면 기존의 Answer값과의 비교를 통해 필요할 경우 값을 갱신하는 로직이 필요할 것입니다.

    2-2. 반복문,조건문을 통해 Backtrack 함수 재귀호출
    마지막으로 구현해야 할 부분은 백트래킹에서 가장 중요한 부분은 탐색과 선택 부분입니다. 여러갈래의 길 중 조건을 만족하는 경우만 (위 예제의 경우, 각 행과 열에서는 한 개의 숫자만 선택) 선택하여 값을 변화시키고 다시 함수를 호출하게 됩니다.  
    조금 더 직관적으로 설명해 보겠습니다. 위의 예제에서 반복문은 갈림길(열 방향 이동), 함수 호출은 깊이(행 방향 이동)라고 생각 하시면 됩니다. 탐색은 동일한 방향으로(0->3) 진행하며, 아래로 더 내려 갈 수 있다면 한 번 더 호출한 후 다음 진행 방향을 선택하는 것입니다.  
    바로 이렇게 말이죠.  
    <그림3>  

    
```
    public class selectNumber {
	static int[][] mat;
	static int[] visited;
	static int Answer;
	public static void main(String[] args) {
        //1. 변수 생성
		mat=new int[][]
			{{ 12, 13, 21, 9 },
		    {42, 39, 50, 45 },
		    {30, 18, 39, 40 },
		    {51, 59, 57, 39 }
			};
		visited=new int[4];
		Answer=0;			//문제의 요구사항(선택한 수들의 합이 가장 큰 경우)

		int sum=0;			//경로상의 선택한 수를 더할 변수
		int cnt=0;			//선택 횟수를 저장할 변수
		
		backtrack(sum,cnt);
		
		System.out.println(Answer);
	}

	private static void backtrack(int sum,int cnt) {
		//2-1. 탈출조건
		if(cnt==4){
			Answer=Math.max(Answer, sum);
            return;
		}
		
		//2-2. 반복문과 조건문을 통한 backtrack함수 호출
		for(int i=0;i<4;i++){
			if(visited[i]==0){
				visited[i]=1;
				sum=sum+mat[i][cnt];
				cnt=cnt+1;
				backtrack(sum, cnt);
				cnt=cnt-1;
				sum=sum-mat[i][cnt];
				visited[i]=0;
			}
		}
	}
}
```
    그림과 비교해가며 코드를 천천히 살펴 보도록 하겠습니다.  
    먼저 '탈출조건'에서 마지막 행까지의 탐색이 끝나는지를 확인합니다. 처음의 변수 cnt의 값은 0이기 때문에 해당되지 않겠네요.  
    다음, 반복문을 통해 열 방향으로 탐색을 시작하려고 합니다. 처음으로 네 갈래길을 만났다고 생각하면 되겠지요. 우리는 0->3 방향으로 탐색을 하기로 정했습니다.  
    문제의 요구조건에서, 각 행에서는 하나씩만 선택 할 수 있기 때문에, 다녀 온 길을 표시할 visited 배열에서 0번 index를 확인합니다. 아직 다녀오지 않았기 때문에 0번 길을 선택하고, visited[0]의 값을 1로 바꿔주기로 합니다. 
    그리고 sum의 값에 선택한 숫자를 더해주게됩니다.
    마찬가지로 한 행에서는 한가지 숫자밖에 선택할 수 없기 때문에 0번 행(cnt=0)에서 cnt를 하나 증가(cnt=cnt+1)시킨 후 재귀호출을 통해 두번째 열에서 숫자를 선택합니다.  

    그 이후부터는 1번 열에서 탐색해가며 visited[i]가 0인 곳에서부터 재귀호출을 시작하여 cnt값이 4가 될때까지 visited, cnt, sum의 값을 갱신해나갑니다.

    가장 먼저 나온 숫자의 세트는 (12,39,39,39)일 것입니다. 각각 (0,0), (1,1), (2,2), (3,3)에서 뽑힌 숫자이지요. 이렇게 마지막 행(3행)까지의 탐색이 모두 끝났습니다. 하지만 컴퓨터는 이 사실을 알지 못하고 다시 한번 함수를 호출하게 되고, 호출된 함수는 '탈출조건'을 만나고 `return;` 명령을 통해 그 아래에 위치한 **"반복문을 수행하기 전에 함수가 종료"**되게 됩니다. 

    호출된 함수가 종료되면 그 다음은 어떻게 될까요? 앞서 재귀함수에서 거듭 강조했던 말이 있습니다.  **함수는 호출되는 즉시 새로운 함수를 생성하여 연산을 수행**한다. 즉, 생성된 함수가 종료되었기 때문에 호출되기 이전으로 돌아가게 됩니다. 
    <그림4>
    
     

    코드를 확인해 봅시다.

    이해가 되시지 않을 경우에는 `visited[i]=1` 부분을 `visited[i]=mat[i][cnt]` 등으로 바꿔서 출력해보시길 추천드립니다.