
탐욕 알고리즘 (greedy algorithm)
====
```
1. 무엇인가? (정의)
2. 언제 사용할 수 있나?
3. 어떻게 사용하는 가?
```

# 1.무엇인가?

탐욕 알고리즘은 한 문장으로 설명하자면, "**각 선택의 순간에 최적인 답을 고르고, 이것을 문제가 끝날 때까지 반복한다!**" 는 해결법이다. '엥? 당연한거 아니냐? 혹은 원래 알고리즘 풀 때 그렇게 하고 있었는데?'라는 생각하고 있었다면, 지금까지 공부 잘못한 거니까 앞의 챕터들을 다시 읽어보길 권한다. 

# 2.언제 사용할 수 있나?

위의 한 문장 설명을 분해해보면
1) 각 선택의 순간에 최적을 고른다 (Greedy choice property)
2) 반복해서 답에 도달한다 (Optimal substructure)

두 단계로 나뉘어있다.
이 두 가지가 바로 탐욕 알고리즘을 사용할 수 있는 조건이며, 이 조건을 충족하지 않는 문제들은 탐욕 알고리즘으로 최적해(답)을 구할 수 없다. 즉, 열심히 코드 짜고 제출해서 10 개 중 7개 맞았다고 조금 더 고치면 될거야! 고려하지 않은 코너 케이스가 있나? 같은 희망을 갖는 게 무의미 하다는 것이다. 그리디 알고리즘의 개 같은 점은 바로 여기서 발생하는 데, 써도 되는 거야? 마는 거야? 를 확실하게 판단하기가 진짜 어렵다는 점이다. 실제로 올림피아드 출신들도 어렵다고 하니 아래 설명으로 아 이런거구나! 기본적인 부분만 이해하고, 확실히 적용된다고 증명된 예제와 그 변형임을 확신할 수 있을 때만 사용하자. 그게 아니라면 제출해서 부분 점수라도 의미가 있을 때 사용하자.

### **탐욕 선택 조건 Greedy choice property**  
'탐욕 선택 조건'은 지금의 선택(부분 문제의 해)은 지금까지 결정에 종속되고, 선택 이 후의 변수나 문제 전체에 영향을 받지 않는 다는 의미이다. 쉽게 설명하기 무척 어려운 문장인데, 여러가지 다른 표현으로 다시 설명해보자면 아래와 같다.
1. 매 선택(부분 문제의 해)을 최적으로 수행하면, 문제의 크기가 점점 줄어든다
2. 이미 지나간 선택을 바꾼다고 지금의 선택의 더 효율적으로 변하지 않는다. 즉, 뒤를 돌아볼 필요가 없다. (동적 계획법의 문제 성립조건과 가장 핵심적인 차이다)  
이 조건을 충족하는 예를 들자면, n 번째 선택에서 최적 조건에 해당하는 답이 여러 개 있을 때, 어느 것을 선택해도 n+m 번째 선택의 최적해가 변하지 않는 다면 탐욕 선택 조건이 성립한다. 전체 문제를 부분 문제로 쪼개서 풀어도, 각각이 최적의 답을 선택하는 데 영향을 미치지 않는 독립적인 관계라는 것이다. 

### **최적 부분 구조 Optimal substructure ** 
'최적 부분 구조'는 전체의 최적해는 무조건 부분 문제의 최적해를 포함한다는 것이다. 동시에 전체 문제를 쪼개서 구한 최적해가 무조건 전체 최적해에 들어간다는 뜻이다. 동적계획법 문제와 같은 전제조건이고, 이 때문에 알고리즘 문제들을 풀 때 그리디인가? DP인가? 헷갈리게 만드는 이유이기도 하다.

위 두가지 조건을 엄밀하진 않지만 더 쉬운 말로 바꾸면, "문제를 쪼개서 풀어도 된다", "쪼개서 푼 답을 합치면 전체 답이다" 정도라고 볼 수 있다. 가장 쉽게 거르는 방법은 문제를 쪼개서 푼 답이 전체 답에 들어가지 않을 경우이다. ("쪼개기"를 잘못하는 경우를 빼고..)

### 대표적으로 해결 가능한 사례

1. 최소 신장 트리 (Minimum spanning tree)
    1. 크루스칼 알고리즘 (Kruskal’s algorithm)
2. 다익스트라 알고리즘(Dijkstra's Algorithm)
3. 결정 트리 학습법(Decision Tree Learning)
4. 활동 선택 문제(Activity selection problem)

# 3. 어떻게 사용하는 가?
* 주의, 이건 그리디 알고리즘을 "짜는", 즉 코드화하는 과정이지 그리디 알고리즘으로 "최적해가 구해진다"고 증명하는 과정이 아니다.

1. 전체 문제와 후보군 설정 (define solution and candidate)
2. 부분 최적 해 선택 (selection) 
3. 타당성 확인 (feasibility check)
4. 해 추가, 다음 부분 문제로 이행 (union)
5. 전체 문제가 해결 됐는 지 확인 (solution check)

의사 코드로 나타내면 아래와 같다.
```
Greedy (Set Candidate){ // 최적 해 후보군 집합과 함께 문제 시작
   solution = new Set(); // 최종 해 집합 선언
   while (Candidate.isNotEmpty()) { // 후보군이 남아 있는 한
	   next = Candidate.select(); // 현 스테이지에서 부분 최적해 선택
	   if (solution.isFeasible(next)) { // 타당성 확인
 			solution.union(next); // 해 집합에 부분 최적해 추가
	   		if (solution.solves()) { // 전체 문제가 해결 됐는 지 확인
                   return solution; // 문제 종료
            }
       }
    }
   return null; // 전체 최적 해결이 없다면 잘못 풀었거나, greedy 문제가 아니다.
}
```

## 예제. 거스름돈
서로 값어치가 다른 동전 N개로 K 만큼의 거스름돈을 만드는 데 필요한 최소한의 동전의 수를 구하는 알고리즘을 짜보자. 단, 동전의 개수는 제한이 없고, 거스름돈은 동전들로 만들 수 있는 금액이다.

Step 1) 탐욕 알고리즘 문제인가?
다시 한 번 복창하고 시작한다. "**각 선택의 순간에 최적인 답을 고르고, 이것을 문제가 끝날 때까지 반복한다**". 탐욕 알고리즘 문제인지 확인하기 위해 동전 종류는 [10, 50, 100], 거스름 돈은 350원인 예제 입력을 가정해보자. 

이건 10x + 50y + 100z = 350 일 때 x+y+z 의 최소값은? (x,y,z는 정수) 으로 치환해볼 수 있다.
위 식을 만족하는 모든 x,y,z 집합을 탐색하는 것 (x,y,z에 정수를 다 때려넣어본다) 같은 짓거리를 안할려고 탐욕이나 DP 같은 방법이 연구되어 온 것이다.

직관적으로 보기에, 단위가 큰 동전을 먼저 채워넣고 작은 동전을 넣어야 최소값이 될 듯하다. 다시 말해, 10, 50, 100 중 350을 구성하는 데 가장 많은 부분을 100이 차지해야 사용량이 최소화된다는 것이다. 이를 일반화해서 10,50,100 등 동전 단위를 a1, a2, a3 ... an 으로 놓고 보면 이 것이 약수 집합인 경우 성립한다. a1 < a2 이고, a1이 a2의 약수일 때, a1 * p = a2 * q = k 를 만족하는 p < q 는 존재하지 않기 때문이다. (모든 수 는 정수). 따라서, 가장 가치가 큰 동전을 먼저 채워나가면(부분 문제 해결) 필요한 전체 동전 수의 최소 (전체 문제)를 해결 할 수 있다. 

Step 2) 코드 작성하기
위의 문제에 대해, 입력/출력 형식이 지정되지 않은 형태로 간단히 코드를 짜보면 아래와 같다.

```
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

public class Main {
    public static void main(String[] args) {
        /**
            더 범용적이기 위해선, 동전들이 약수 관계인지 문제 자체의 성립을 검토해야하지만 그건 독자들의 몫으로 남겨두겠다.
        **/
        ArrayList<Integer> coins = new ArrayList<>(Arrays.asList(50,100,310));
        int exchange = 350;

        // do-while 내 for 루프에서 큰 동전 먼저 선택하기 위해 먼저 정렬해둠. 
        // selection 의 일부를 미리 처리 해둔것
        Collections.sort(coins, Collections.reverseOrder());

        //최종 해로 사용하는 동전들의 횟수를 기록할 배열
        int [] answer = new int [coins.size()];
        int remain = exchange;
        
        do{

            //채워나가는 단위를 큰 동전 먼저 선택 (selection)
            for(int i=0; i<coins.size();){
                
                //동전이 남은 거스름돈보다 큰지 확인하는 if-else (feasibility check)
                if(remain >= coins.get(i)){
                    remain -= coins.get(i); 
                    //최종 해 집합에 추가
                    answer[i]++;
                } else {
                    i++;
                }
            }
            if(remain<0){
                System.out.println("retard");
                break;
            }
        } while(remain > 0 ) 
        ////거스름 돈이 0이 되면 문제해결

        // 답 출력
        System.out.println(coins);
        for(int i : answer) {
            System.out.print(i+" ");
        }
    }
}


```